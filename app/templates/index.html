<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <script>
        var page_url = window.location.protocol + "//" + window.location.host + window.location.pathname;
    </script>
    <link id='style' rel="stylesheet" href="static/style/main.css">
	<script>document.getElementById("style").href = page_url + "static/style/main.css"</script>

    <link href="https://fonts.googleapis.com/css?family=Montserrat&display=swap" rel="stylesheet">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.0.13/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/select2@4.0.13/dist/js/select2.min.js"></script>
  </head>
  <body>
    <h1>Keyword Emergence Visualizer <span id="version">(version: {{ version }})</span></h1>
    <div style="width: 100%; overflow: hidden; margin-left: 4%">
      <div style="width: 50%; float: left; margin-top: 20px; margin-bottom: 0px">
        <p id="description">
          We calcluated many measures from the the frequencies of keywords in the Astrophysics Data System (ADS).
          The two dropdowns contain names of values calculated from the keyword time series.
          A list of these measures can be found <a href="https://tsfresh.readthedocs.io/en/latest/text/list_of_features.html">here</a>.
          Code for generating this information can be found <a href="{{ git_url }}">here</a>.<br><br>
          On the left, there are a few predefined views which may be useful.
        </p>
      </div>
      <div id='options' style="margin-left: 50px; margin-top:0px">
        <ul style="list-style-type:none">
          <li>x: <select id="selectButtonX" class="selector"></select></li>
          <li>y: <select id="selectButtonY" class="selector"></select></li>
          <li><button type="button" id="enterButton">Transform</button></li>
          <li><br></li>
          <li><button type="button" id="toggleNorm">Toggle Time Series Normalize</button></li>
        </ul>
      </div>
    </div>
    <div style="width: 100%; overflow: hidden;">
      <div id="views" style="width: 100px; float: left; margin-top: 50px">
        <div class="btn-group">
          <button id="cagrNasaafil">CAGR vs NASA Affiliation</button>
          <button id="manifold">manifold</button>
          <button id="maxSkew">First max location vs skewness</button>
          <button id="changeComplex">mean change vs complexity</button>
        </div>
      </div>
      <div id="plots" style="margin-left: 100px; height: 100%"></div>
    </div>
    <br>

    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script type="text/javascript">
      // When the button is changed, run the updateChart function
      function update(selectedX, selectedY) {
        console.log(selectedX);
        console.log(selectedY);
      }

      // Input the data
      function scatterChart() {
        var margin = 50;
        var height = 300;
        var width = 500;

        var xName = 'value__mean_change';
        var yName = 'value__cid_ce__normalize_True';
        var labelName = 'stem';
        var colorName = 'kmeans_cluster';
        var sizeVal = "scaled_counts";
        var sizeName = 'count';

        var xValue = function(d) { return d[xName]; };
        var yValue = function(d) { return d[yName]; };
        var cValue = function(d) { return d[colorName];};

        var xScale = d3.scaleLinear();
        var yScale = d3.scaleLinear();
        var xAxis;
        var yAxis;

        var color = d3.scaleOrdinal(d3.schemeCategory10);

        var brush;
        var svg;
        var scatter;
        var xExtent;
        var yExtent;
        var idleTimeout;
        var idleDelay = 350;
        var timeSvg;
        var timeChart =  timeSeriesChart();

        function my(selection) {
          selection.each(function (data, i) {
            svg = d3.select(this);

            var g = svg.append('g')
            .style('transform', 'translate(10%, 10%)');

            scatter = g.append("g")
            .attr("id", "scatterplot")
            .attr("clip-path", "url(#clip)");

            var clip = g.append("defs").append("svg:clipPath")
            .attr("id", "clip")
            .append("svg:rect")
            .attr("width", width+10)
            .attr("height", height+10)
            .attr("x", 0)
            .attr("y", 0)
            .attr("transform", "translate(0,-10)");

            var xAxisEl = g.append("g")
            .attr("class", "x axis")
            .attr('id', "axis--x")
            .attr("transform", "translate(0," + height + ")");

            var yAxisEl = g.append("g")
            .attr("class", "y axis")
            .attr('id', "axis--y");

            var xAxisTitleEl = g.append("text")
            .attr('class', 'axis_title')
            .style("text-anchor", "middle")
            .attr('class', 'axis_title')
            .attr("transform", `translate(${width/2}, ${height + 30})`);

            var yAxisTitleEl = g.append("text")
            .attr('class', 'axis_title')
            .attr("transform", "rotate(-90)")
            .attr("y", -45)
            .attr("x",0 - (height / 2))
            .style("text-anchor", "middle")
            .attr("dy", "1em");

            g.append("text")
            .attr("transform", "translate(10,0)")
            .attr("x", 0)
            .attr("y", -20)
            .attr("class", "title")
            .text(`Keywords Time Series Measures`);

            brush = d3.brush().extent([[0, 0], [width, height]]).on("end", brushended);
            scatter.append("g")
            .attr("class", "brush")
            .call(brush);

            xScale.range([0, width]);
            yScale.range([height, 0]);
            xAxis = d3.axisBottom(xScale).ticks(12);
            yAxis = d3.axisLeft(yScale).ticks(12 * height / width);

            // data dependent
            xExtent = d3.extent(data, function (d) { return d[xName]; });
            yExtent = d3.extent(data, function (d) { return d[yName]; });

            xScale.domain(xExtent).nice();
            yScale.domain(yExtent).nice();

            scatter.selectAll(".dot")
            .data(data)
            .enter().append("circle")
            .attr("class", "dot")
            .attr("pointer-events", "all")
            .attr("clip-path", "url(#clip)")
            .call(tooltip())
            .on("click", onClick)
            .attr("r", function (d) { return d[sizeVal]; })
            .attr("cx", function (d) { return xScale(d[xName]); })
            .attr("cy", function (d) { return yScale(d[yName]); })
            .attr("opacity", 0.5)
            .style("fill", function(d) { return color(cValue(d));});

            xAxisEl
            .call(xAxis);

            xAxisTitleEl
            .text(xName);

            yAxisEl
            .call(yAxis);

            yAxisTitleEl
            .text(yName);
          });
        }

        function brushended() {
          var s = d3.event.selection;
          if (!s) {
            if (!idleTimeout) return idleTimeout = setTimeout(idled, idleDelay);
            xScale.domain(xExtent).nice();
            yScale.domain(yExtent).nice();
          } else {
            xScale.domain([s[0][0], s[1][0]].map(xScale.invert, xScale));
            yScale.domain([s[1][1], s[0][1]].map(yScale.invert, yScale));
            scatter.select(".brush").call(brush.move, null);
          }
          zoom();
        }

        function idled() {
          idleTimeout = null;
        }

        function zoom() {
          var t = scatter.transition().duration(750);
          svg.select("#axis--x").transition(t).call(xAxis);
          svg.select("#axis--y").transition(t).call(yAxis);
          scatter.selectAll("circle").transition(t)
          .attr("cx", function (d) { return xScale(d[xName]); })
          .attr("cy", function (d) { return yScale(d[yName]); });
        }

        function onClick(d, i) {
          d3.json(window.location.pathname + 'get-time-data', {
            method:"POST",
            body: JSON.stringify({
              stem: d[labelName], kmeans_cluster: d[colorName]
            }),
            headers: {
              "Content-type": "application/json; charset=UTF-8"
            }
          }).then(
            function(data) {
              console.log(data);
              timeChart.data(data);
            }
          )
        }

        function tooltip() {
          var tooltipDiv;
          var bodyNode = d3.select('body').node();

          function tooltip(selection){

            selection.on('mouseover.tooltip', function(pD, pI){
              // Clean up lost tooltips
              d3.select('body').selectAll('div.tooltip').remove();
              // Append tooltip
              tooltipDiv = d3.select('body')
              .append('div')
              .attr('class', 'tooltip');
              var absoluteMousePos = d3.mouse(bodyNode);
              tooltipDiv
              .style('left', (absoluteMousePos[0] + 10)+'px')
              .style('top', (absoluteMousePos[1] - 40)+'px');

              var kwd = pD['stem'].replace('<', '&lt;').replace('>', '&gt;');
              var line1 = '<p><strong>' + kwd + '</strong></p>';
              var line2 = `<p>${xName}: ` + pD[xName].toFixed(2) + '</p>';
              var line3 = `<p>${yName}: ` + pD[yName].toFixed(2) + '</p>';
              var line4 = `<p>count: ` + pD[sizeName] + '</p>';
              var line5 = `<p>cluster: ` + pD[colorName] + '</p>';


              tooltipDiv.html(line1 + line2 + line3 + line4 + line5)
            })
            .on('mousemove.tooltip', function(pD, pI){
              // Move tooltip
              var absoluteMousePos = d3.mouse(bodyNode);
              tooltipDiv.style({
                left: (absoluteMousePos[0] + 10)+'px',
                top: (absoluteMousePos[1] - 40)+'px'
              });
            })
            .on('mouseout.tooltip', function(pD, pI){
              // Remove tooltip
              tooltipDiv.remove();
            });

          }

          tooltip.attr = function(_x){
            if (!arguments.length) return attrs;
            attrs = _x;
            return this;
          };

          tooltip.style = function(_x){
            if (!arguments.length) return styles;
            styles = _x;
            return this;
          };

          return tooltip;
        }

        // getter-setters
        my.data = function (value) {
          if (arguments.length === 0) return data;
          data = value;
          if (typeof updateData === 'function') updateData();
          return my;
        };

        my.height = function (value) {
          if (arguments.length === 0) return height;
          height = value;
          return my;
        };

        my.width = function (value) {
          if (arguments.length === 0) return width;
          width = value;
          return my;
        };

        my.xName = function (value) {
          if (arguments.length === 0) return xName;
          xName = value;
          return my;
        };

        my.yName = function (value) {
          if (arguments.length === 0) return yName;
          yName = value;
          return my;
        };

        my.colorName = function (value) {
          if (arguments.length === 0) return colorName;
          colorName = value;
          return my;
        };

        my.sizeVal = function (value) {
          if (arguments.length === 0) return sizeVal;
          sizeVal = value;
          return my;
        };

        my.sizeName = function (value) {
          if (arguments.length === 0) return sizeName;
          sizeName = value;
          return my;
        };

        my.labelName = function (value) {
          if (arguments.length === 0) return labelName;
          labelName = value;
          return my;
        };

        my.timeSvg = function(value) {
          if (!arguments.length) return timeSvg;
          timeSvg = value;
          return my;
        };

        my.timeChart = function(value) {
          if (!arguments.length) return timeChart;
          timeChart = value;
          return my;
        };

        my.color = function(value) {
          if (!arguments.length) return color;
          color = value;
          return my;
        };

        return my;
      }

      function timeSeriesChart() {

        var data = [];
        var height = 400;
        var width = 800;

        var xName = 'year';
        var yName = 'count';
        var colorName = 'kmeans_cluster';
        var cValue = function(d) { return d[colorName];}; // Won't change with colorName;
        var color = d3.scaleOrdinal(d3.schemeCategory10);

        var parseTime = d3.timeParse("%Y");
        var xTime = d3.scaleTime();
        var yTime = d3.scaleLinear();
        var formatData;

        function my(selection) {
          selection.each(function() {
            svg = d3.select(this);
            const t = svg.transition().duration(750);

            xTime.range([0, width]);
            yTime.range([height, 0]);

            var tg = svg.append('g')
            .style('transform', 'translate(10%, 10%)');

            var g = tg.append("g")
            .attr("id", "timeSeries");

            var xAxisEl = g.append("g")
              .attr('id', 'xAxis');

            var yAxisEl = g.append("g")
              .attr('id', 'yAxis');

            formatData = function(d) {
              d[xName] = parseTime(d[xName]);
              console.log(d[xName]);
              d[yName] = +d[yName];
              console.log(d[yName]);
            };

            updateData = function() {
              data.forEach(formatData);
              _updateData();
            };

            _updateData = function() {
              xTime.domain(d3.extent(data, function(d) { return d[xName]; }));
              yTime.domain([0, d3.max(data, function(d) { return d[yName]; })]);

              var line = d3.line()
              .x(function(d) { return xTime(d[xName]); })
              .y(function(d) { return yTime(d[yName]); });

              var area = d3.area()
              .x(function(d) { return xTime(d[xName]); })
              .y0(height)
              .y1(function(d) { return yTime(d[yName]); });

              xAxisEl
              .attr("transform", "translate(0," + height + ")")
              .call(d3.axisBottom(xTime).ticks(d3.timeYear.every(1)))
              .selectAll("text")
              .join('text')
              .attr("y", 10)
              .attr("x", -10)
              .attr("dy", ".35em")
              .attr("transform", "rotate(0)")
              .style("text-anchor", "start");

              yAxis = d3.axisLeft(yTime).tickFormat(function(d){
                return d;
              }).ticks(5);

              yAxisEl
              .transition(t)
              .call(yAxis);

              var tmpColor = color(cValue(data[0])); // All the same so get first

              g.selectAll(".area")
              .data([data])
              .join(
                  enter => enter.append('path')
                  .attr("d", area)
                  .style("stroke", tmpColor),
                  update => update
                  .call(update => update.transition(t)
                          .attr('d', area)
                          .style('fill', tmpColor)
                  )
              )
              .attr("class", "area");

              // add the valueline path.
              g.selectAll(".line")
              .data([data])
              .join(
                enter => enter.append('path')
                  .attr("d", line)
                  .style("stroke", tmpColor),
                update => update
                  .call(update => update.transition(t)
                    .attr('d', line)
                    .style('stroke', tmpColor)
                  )
              )
              .attr("class", "line");

              g.selectAll('circle')
              .data(data)
              .join(
                enter => enter.append("circle")
                  .attr("r", 4)
                  .style('opacity', 0.5)
                  .style('fill', tmpColor)
                  .attr("cx", function(d) { return xTime(d[xName]); })
                  .attr("cy", function(d) { return yTime(d[yName]); }),
                update => update
                  .call(update => update.transition(t)
                    .style('fill', tmpColor)
                    .attr("cx", function(d) { return xTime(d[xName]); })
                    .attr("cy", function(d) { return yTime(d[yName]); })
                  ),
              );

              g.selectAll('.title')
              .data([data[0]['stem']])
              .join(
                enter => enter.append('text').text(function (d) {return `\"${d}\" year versus count`}),
                update => update.text(function (d) {return `\"${d}\" year versus count`}),
              )
              .attr("transform", "translate(10,0)")
              .attr("x", 0)
              .attr("y", -20)
              .attr("class", "title");
            };

            updateData();

            g.append("text")
            .style("text-anchor", "middle")
            .attr('class', 'axis_title')
            .attr("transform", `translate(${width/2}, ${height + 30})`)
            .text(xName);

            g.append("text")
            .attr("transform", "rotate(-90)")
            .attr('class', 'axis_title')
            .style("text-anchor", "middle")
            .attr("y", -45)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .text(yName);

          })
        }

        // getter-setters
        my.data = function (value) {
          if (arguments.length === 0) return data;
          data = value;
          if (typeof updateData === 'function') updateData();
          return my;
        };

        my.height = function (value) {
          if (arguments.length === 0) return height;
          height = value;
          return my;
        };

        my.width = function (value) {
          if (arguments.length === 0) return width;
          width = value;
          return my;
        };

        my.xName = function (value) {
          if (arguments.length === 0) return xName;
          xName = value;
          return my;
        };

        my.yName = function (value) {
          if (arguments.length === 0) return yName;
          yName = value;
          if (typeof _updateData === 'function') _updateData();
          return my;
        };

        my.colorName = function (value) {
          if (arguments.length === 0) return colorName;
          colorName = value;
          return my;
        };

        my.color = function(value) {
          if (!arguments.length) return color;
          color = value;
          return my;
        };

        return my;
      }
      $(document).ready(function() {
        $('.selector').select2();
      });

      $(".selector").select2({
        width: 'resolve' // need to override the changed default
      });

      var margin = { top: 20, right: 70, bottom: 100, left: 20 };
      var width = 600 - margin.left - margin.right;
      var height = 450 - margin.top - margin.bottom;

      var swidth = width + margin.left + margin.right;
      var sheight = height + margin.top + margin.bottom;

      var color = d3.scaleOrdinal(d3.schemeCategory10);

      var svgScaler = 1;

      // Append SVG
      var scatterSvg = d3.select('#plots')
        .append("svg")
        .attr("width", swidth * svgScaler)
        .attr("height", sheight * svgScaler)
        .attr("transform", "translate(" + (margin.left * svgScaler) + "," + (margin.top  * svgScaler) + ")");

      var timeSvg = d3.select("#plots")
      .append("svg")
      .attr('id', 'timeSvg')
      .attr("width", swidth * svgScaler)
      .attr("height", sheight * svgScaler)
      .attr("transform", "translate(" + (margin.left * svgScaler) + "," + (margin.top * svgScaler) + ")");

      // Add time series chart
      var timeChart = timeSeriesChart()
      .height(height)
      .width(width)
      .color(color);

      // add slope comp chart
      var chart0 = scatterChart()
      .height(height)
      .width(width)
      .xName('value__mean_change')
      .yName('value__cid_ce__normalize_True')
      .timeSvg(timeSvg)
      .timeChart(timeChart)
      .color(color);

      // add manifold chart
      var chart1 = scatterChart()
      .height(height)
      .width(width)
      .xName('manifold_x')
      .yName('manifold_y')
      .timeSvg(timeSvg)
      .timeChart(timeChart)
      .color(color);

      d3.json(window.location.pathname + "get-scatter-data", {
            method:"POST",
            body: JSON.stringify({
              x: 'value__mean_change', y: 'value__cid_ce__normalize_True'
            }),
            headers: {
              "Content-type": "application/json; charset=UTF-8"
            }
          })
        .then(function(data) {
          scatterSvg
            .datum(data)
            .call(chart0);
          });

      d3.json(window.location.pathname + 'get-all-options')
        .then(
          function(options) {
            d3.select("#selectButtonX")
            .selectAll('myOptions')
            .data(options)
            .enter()
            .append('option')
            .text(function (d) { return d; }) // text showed in the menu
            .attr("value", function (d) { return d; }); // corresponding value returned by the button

            d3.select("#selectButtonY")
            .selectAll('myOptions')
            .data(options)
            .enter()
            .append('option')
            .text(function (d) { return d; }) // text showed in the menu
            .attr("value", function (d) { return d; }); // corresponding value returned by the button

            d3.select("#enterButton").on("click", function(d) {
              // recover the option that has been chosen
              var selectedX = d3.select("#selectButtonX").property("value");
              var selectedY = d3.select("#selectButtonY").property("value");
              scatterSvg.selectAll('*').remove();
              d3.json(window.location.pathname + "get-scatter-data", {
                method:"POST",
                body: JSON.stringify({
                  x: selectedX, y: selectedY
                }),
                headers: {
                  "Content-type": "application/json; charset=UTF-8"
                }
              })
                .then(function(data) {
                  scatterSvg
                    .datum(data)
                    .call(chart0.xName(selectedX).yName(selectedY));
                  });
              }
            )}
        );

      d3.json(window.location.pathname + 'get-all-time-data')
        .then(
          function(data) {
            console.log(data);
            timeSvg.call(timeChart.data(data));
          }
      );

      d3.select('#toggleNorm').on('click', function(d) {
        tc = chart0.timeChart();
        if (tc.yName() === 'count') {
          tc.yName('norm_count')
        } else {
          tc.yName('count')
        }
      });

      function scatterRequestPlot(d, selectedX, selectedY) {
        // recover the option that has been chosen
        // let selectedX = 'manifold_x';
        // let selectedY = 'manifold_y';
        scatterSvg.selectAll('*').remove();
        d3.json(window.location.pathname + "get-scatter-data", {
          method:"POST",
          body: JSON.stringify({
            x: selectedX, y: selectedY
          }),
          headers: {
            "Content-type": "application/json; charset=UTF-8"
          }
        })
        .then(function(data) {
          scatterSvg
          .datum(data)
          .call(chart0.xName(selectedX).yName(selectedY));
        });
      }

      // Saved views
      d3.select("#cagrNasaafil").on("click", function (d) {
                let x = 'nasa_afil';
                let y = 'cagr';
                return scatterRequestPlot(d, x, y);
              }
      );

      d3.select("#manifold").on("click", function (d) {
          let x = 'manifold_x';
          let y = 'manifold_y';
          return scatterRequestPlot(d, x, y);
        }
      );

      d3.select("#maxSkew").on("click", function (d) {
                let x = 'value__skewness';
                let y = 'value__first_location_of_maximum';
                return scatterRequestPlot(d, x, y);
              }
      );

      d3.select("#changeComplex").on("click", function (d) {
                let x = 'value__mean_change';
                let y = 'value__cid_ce__normalize_False';
                return scatterRequestPlot(d, x, y);
              }
      );


    </script>
  <footer id="footerInfo">
    <p style="font-size: 16px">For questions, contact <a href = "mailto: anthony.r.buonomo@nasa.gov">anthony.r.buonomo@nasa.gov</a> or <a href = "mailto: brian.a.thomas@nasa.gov">brian.a.thomas@nasa.gov</a>.</p>
  </footer>
  </body>
</html>
